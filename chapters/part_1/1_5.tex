\newpage
\chapter{Hype-Driven Development}
\label{ch:hype_driven}
%\addcontentsline{toc}{chapter}{1\textonehalf \quad Hype-Driven Development}

\begin{navigationbox}{Setting the Scene: The Hackathon Origin}
The story of our trio didn’t begin in a stuffy interview room, but at the ”Hack-the-Future-of-
Beverages-2024” hackathon, sponsored by a venture capital fund with an unpronounceable
name. The challenge was as simple as it was absurd: ”Create a disruptive solution for the
coffee industry using AI, IoT, and Web3.”
\end{navigationbox}

\section{Dream Team and the Blockchain of Coffee}
\label{sec:parable_dream_team}



\paragraph{Ivan, the "Startup Visionary,"} came to win. His project, "Aroma-Chain," proposed NFT traceability for every single coffee bean. Each bean was to be 3D-scanned, its aroma digitized by a neural network, hashed with SHA-512, and minted as a unique NFT on the Solana blockchain. "The user can not only see their coffee's journey from the plantation but also tip the farmer who grew that very bean!" Ivan proclaimed from the stage, as logos for Docker, Kubernetes, and TensorFlow flashed on the screen behind him. His presentation ended in a storm of applause and a shower of investor business cards.

\paragraph{Peter, the "Engineer of Trench-Warfare Truth,"} stumbled upon the hackathon by accident. A friend had told him there would be free pizza. Peter came with a single idea: a reliable coffee machine. He brought an old industrial manipulator he'd saved from the scrapyard at his plant and a Siemens PLC. His "innovation" was that the machine would never break down. He used mechanical relays for critical operations and wrote all the logic in Ladder Logic because "a graphical representation is truth and requires no comments." When the judges asked him about AI, he shrugged and said, "I have a thermocouple. If the temperature goes above 92 degrees, I shut off the heating element. That's 'intelligence' that has been proven for decades."

\paragraph{Maria, the "Architect-Purist,"} was on the judging panel. She listened to the pitches with an expression of polite sorrow. After Ivan's presentation, she asked just one question: "Does your system ensure transactional integrity between the state of the coffee bean in the physical world and its representation on the distributed ledger? How do you solve the Byzantine Generals Problem if one of the humidity sensors starts lying?" Ivan blinked and answered confidently, "We'll just add another Redis cache for validation."

Peter, on the other hand, received this feedback from her: "Your approach is certainly robust, but it represents a monolithic architecture with tight coupling between hardware components. The lack of an abstraction layer makes the system un-extensible." Peter nodded and said, "But it doesn't fail. Ever."

\begin{tipbox}{The Unholy Alliance}
Their paths would have never crossed again if not for an investor named Steve. Steve was a man of the new age: he wore a hoodie with his fund's logo, drank smoothies, and believed any business could be "hacked." He was thrilled by Ivan's presentation, impressed by the reliability of Peter's machine, and terrified by Maria's smart words. He decided that if he put them together, he would get the perfect team.
\end{tipbox}

"Guys," he told them in the VIP lounge, "I have a billion-dollar idea. Forget coffee. We're going to build a robot that makes craft, organic, gluten-free beer! Ivan, you'll make it trendy and run it on microservices. Peter, you'll make sure it doesn't explode. And Maria, you'll... well, you'll make sure it's done right."

And so, they got their first project, which Steve, with a glint in his eye, named \textbf{"Beer-as-a-Service (BaaS)"}, with future plans to expand to \textbf{"Hard-Beer-as-a-Service (Hard BaaS)"} for cider production. The idea was simple, like all genius ideas: a robot-bartender that doesn't just pour beer, but creates a "unique user experience."

\subsection*{First Meeting and the Ontology of Hops}
\label{sec:parable_first_meeting}

The team gathered in their new basement office, which now smelled not only of rosin flux but also of trendy Citra hops, a sample of which Ivan had brought for "inspiration."

Ivan, a true Scam Master, immediately created a Kanban board in Jira, set up a CI/CD pipeline that deployed "Hello, World!" to an AWS Lambda function on every commit, and started a Slack channel. "Okay, team," he said, "we're doing one-week sprints because 'agile' means speed. For the first sprint, we'll build the MVP: the robot must be able to identify an empty glass using AI and post about it on Twitter with the hashtag \#BaaS. We'll call the feature 'Glass-Awareness'."

Peter, meanwhile, had brought a decommissioned but eternal-as-the-pyramids solenoid valve from his plant and began testing its continuity with his grandfather's multimeter. His first task was to make the valve open and close with a deterministic delay, not "eventually, if you're lucky." He wasn't interested in Twitter; he was interested in line pressure and actuation time.

Maria, however, walked up to her pristine whiteboard and wrote the title: \textit{"Prolegomena to the Formal Semantics of Fermented Beverages, Vol. 1: The Ontological Foundations of Brewing."}

"Colleagues," she began, in the tone of a professor explaining category theory to freshmen, "before we proceed with implementation, we must achieve consensus on the terminology. What *is* 'beer'? Is it an instance of the `FermentedBeverage` class, or is it a `ValueObject` within the `Serving` aggregate? Is the pouring process an idempotent operation? If we call `pour(500ml)` twice, do we get a liter of beer or an error?"

Ivan, not missing a beat, replied, "That depends on whether we use eventual or strong consistency. I propose Kafka. We'll publish a `PourRequest` event, and workers will process it. If something goes wrong, we can always roll back the transaction with a Saga pattern." He was already picturing a beautiful diagram of message queues for his next conference talk.

Peter stared at them as if they were aliens. "This is a valve," he said, tapping it with a screwdriver. "You give it 24 volts, it opens. Beer flows. You take away the 24 volts, it closes. Beer stops flowing. If you give it 36 volts, it burns out. That's your whole 'axiomatic system'."

Maria made a note in her Moleskine notebook: "Investigate the formal verifiability of solenoid behavior under unstable voltage conditions."

Meanwhile, the first theorem appeared on the whiteboard, derived by Maria: \textbf{"A beverage cannot be simultaneously 'Hoppy' and 'Balanced' within a single pouring session unless we introduce the concept of 'Flavor-State Quantum Superposition,' which collapses upon the consumer's first sip."}

Ivan, to show he was a team player, offered a brilliant "compromise." "Maria, this is awesome! You can define your ontology in a Protobuf schema. We'll host it in our monorepo. I'll spin up a gRPC service in Go that validates requests against this schema. Peter, you can send binary requests from your C code to this service to know what to do next. The speed will be insane! And it's all enterprise-level!"

Peter said nothing, but his face clearly read \hcode{Error: Segmentation Fault (core dumped)}. He pulled a spool of thick copper wire from his box and began winding it into something that suspiciously resembled a choke. "There's going to be interference," he muttered to himself. "Their gRPC is definitely going to cause interference."

\begin{infobox}{The Untouchable Artifact}
At the heart of this future technological marvel lay an untouchable artifact: a folder named \hcode{/legacy-core/}. It contained 10,000 lines of undocumented Bash code written by a mysterious ex-contractor named "Dmitri." This script, rumor had it, controlled the main water valve for the entire building. No one dared touch it. It just worked. And the entire team subconsciously understood that their high-tech BaaS startup depended on a script that began with \hcode{\#!/bin/bash} and contained lines like \hcode{sleep 5 \# VERY important delay, do not remove!!!}.
\end{infobox}

And so the first sprint began.

\section{Honeymoon in Tech Hell}
\label{sec:parable_honeymoon}

The phase began which Ivan, in his Medium blog, called the "Execution Phase." Maria, in her academic paper, referred to it as "Formal Specification Implementation." And Peter, to himself, called it "The Day the Adults Leave the Room." The team dispersed to their respective corners to create magic.

\subsection*{Empire of Microservices and Emotional Support}

Ivan dove headfirst into creating the infrastructure. To him, the robot was merely a "thin client," an endpoint for his magnificent cloud architecture.

\begin{principlebox}{ROS 2... and 3?}
Ivan decided that ROS 2 was already yesterday's news. He began writing his own "framework-shim" on top of ROS 2, which he named \textbf{ROS 3-Ready}. It consisted of a set of Python decorators that did nothing but add \hcode{@ros3_compatible} annotations to the code. "We have to be future-proof, guys," he explained.
\end{principlebox}

Every single ROS node, even one that just published "Hello, World," was wrapped in a separate Docker container. This was all orchestrated via a \hcode{docker-compose} file, which was, in turn, launched from a \hcode{Makefile}, which was called by a Python script. When Peter asked "Why?", Ivan replied, "To ensure environmental isolation and reproducibility!" The fact that it all ran on a single computer under the desk didn't bother him.

Ivan faced a problem: how to transmit the "pour beer" command from a ROS node to Peter's driver? A simple function call was "not sufficiently resilient." He implemented the following scheme: the ROS node published the command to a Kafka topic. A separate service in Node.js picked it up, wrote a hash of the command to a private Hyperledger blockchain "for audit purposes," and placed the command itself into Redis. To guarantee delivery, he spun up three Redis instances: \hcode{prod-redis}, \hcode{canary-redis}, and \hcode{emotional-support-redis}, with cross-consistency managed by his own synchronizer script. Finally, the commands for the driver were exported to a Google Sheet via Zapier, "so the business analysts can see the workflow in real-time." Peter was expected to read commands from this spreadsheet.

Before every \hcode{docker-compose up}, Ivan would put on his headphones, blast the Cyberpunk 2077 soundtrack at full volume, and run \hcode{cmatrix} in a separate terminal. He called it "meditating to immerse in the digital flow."

\subsection*{Unkillable Driver and Analog Truth}

Peter ignored the Google Sheet. He took it as a personal insult. He decided to create his own, one true communication channel.

He took Modbus as a basis but found it "too verbose." He developed his own binary protocol over RS-485. Every single bit in every byte had a meaning. The most significant bit of the seventh byte, for instance, meant "turn on the tap's backlight, but only if it's a Tuesday and the line voltage hasn't dipped in the last 3 hours." The protocol was brilliant in its efficiency and utterly unreadable to anyone but Peter.

His driver was a masterpiece of "trench-warfare programming." No \hcode{new} or \hcode{malloc}. All memory was allocated statically at startup. The entire code was in a single \hcode{driver.c} file spanning 3000 lines. To handle states, he used \hcode{goto} and labels because "a switch statement has unnecessary overhead from the jump table." His code was so optimized it could have run on a washing machine's microcontroller.

Peter didn't trust software limits. He installed physical limit switches around the robot, salvaged from an old conveyor belt. If the robot moved out of bounds, the switch would physically break the power circuit to the motors. "A mechanical relay is truth. Everything else is magic and JavaScript," he would say, pointing to a massive contactor.

To check the voltage in a circuit, Peter used the old-school method: he would lick the contacts for a split second. "Tastes like 24 volts. Stable. It works."

\subsection*{The Great Treatise on Beer}

Maria did not write a single line of executable code. Her contribution was a 96-page PDF document titled \textbf{"Speculative Ontologies of Fermented Systems (Version 0.0001-alpha)."}

The document was written in LaTeX and used macros to define system entities. To describe the \hcode{Beer} class, one had to write \hcode{\\defineBeverage[type=ale, ibu=50, color=srm12]\{...\}}. The document was Turing-complete. In theory, it could be compiled to produce... another PDF document.

Maria designed the perfect system. It had no robot, no beer, and no valves. It had an \hcode{AbstractServiceProvider}, an \hcode{ICommandBus}, an \hcode{EventStream}, and a \hcode{StateProjection Repository}. The system was so abstract it could control either a beer-bot or a ballistic missile launch without changing a single line of core code. The problem was that no one, including Maria, knew how to write the "glue" between this divine architecture and the real world.

Maria refused to write unit tests. "Tests only prove the presence of tests, not the absence of bugs," she declared. Instead, she used the TLA+ formal verification system to prove that "the system will never enter a state where the glass is empty and an `OnGlassEmpty` event has not been dispatched." The proof took 40 pages and required a 128-core cluster to verify. The fact that, in the real world, the glass sensor could simply fall off was not considered in the model.

Before adding a new method to an interface, Maria would meditate on the Liskov Substitution Principle and mentally run through all possible covariant and contravariant scenarios.

\begin{infobox}{The State of Play After One Month}
A month passed. Ivan had a cloud infrastructure capable of handling Netflix's launch, but it wasn't connected to the robot. Peter had a driver that could survive an apocalypse, but it only accepted commands in its own secret language. And Maria had a perfect architecture that existed only on paper and in her mind.

They were ready for integration. They were not ready for what was coming.
\end{infobox}

\section{Integration}
\label{sec:parable_integration}

The day arrived that Ivan had marked in Jira as the "Synergy Milestone." 

\subsection*{First Contact: The Doomsday API}

The first problem emerged at the most fundamental level: how could Ivan's service, running in a Docker container on AWS, talk to Peter's driver, which was listening for a custom binary protocol on a PC's COM port?

Ivan, a true evangelist of cloud technologies, declared, "No COM ports! They're not secure and they don't scale. Peter, your driver needs to expose a RESTful API with JWT authentication."

Peter looked at him as if he were a talking llama. "What REST? We are not on a vacation. TX and RX. I send bytes. I receive bytes. That's it."

Maria intervened with a solution that pleased everyone, which is to say, no one: "We will define an \hcode{IValveActuator} interface in Haskell. It will describe the contract. Ivan will write an adapter from REST to this interface, and Peter will write an adapter from the interface to his driver."

In practice, this resulted in Ivan writing yet another microservice in Python that accepted JSON, converted it to YAML, put it in RabbitMQ, from which another service picked it up, converted it to XML, and sent it... to a TCP socket that Peter had opened. Why XML? "Because it's an enterprise standard," Ivan stated with authority.

Peter, in turn, wrote a C program that listened to this socket, parsed the XML (using 15 nested \hcode{if (strstr(...))}), extracted the necessary command, and sent it to the COM port. It was a bridge between Web 3.0 and the Industrial Revolution, and it was hideous.

\subsection*{Architectural Patterns in Action}

Once the first stream of data somehow trickled through, the  system began to take shape.

To create a "live dashboard," Ivan's GUI, written in React, started directly querying the solenoid's state from Peter's driver via a WebSocket. But the driver only responded in its binary protocol. The solution? Ivan wrote a JS library that emulated a COM port in the browser and parsed the binary stream. Now, to change the color of a button in the UI, one had to recompile the frontend, two backend services, and Peter's driver firmware.

Ivan's central service, \hcode{Orchestrator.py}, became a digital deity. It managed ROS nodes, wrote to the blockchain, read from Redis, communicated with the GUI, and now it also parsed Peter's driver logs to predict, using a neural network, when Peter would run out of coffee. If this service crashed, the entire system turned into a pumpkin. And it crashed often, because one of its dependencies required Python 2.7.


Since the system was distributed across five different technologies and three continents (Ivan's servers were in Oregon), there was no single way to debug it. The team invented "cross-platform debugging":
\begin{enumerate}
    \item Peter's driver would blink an LED on the board at a specific frequency.
    \item Ivan would point a webcam at this LED.
    \item A Python script with OpenCV would recognize the blinks, translate them into Morse code, and send them to Slack.
    \item Maria insisted this was unreliable and demanded that, in parallel, logs be written to punch cards for "cold storage."
\end{enumerate}


\begin{minted}{cpp}
Orchestrator.py: (14:01:03) INFO: New BeerRequest received. 
  CorrelationID: deadbeef-1337. Publishing to Kafka.

Peter_Driver.c (via Morse-bot): (14:01:04) ERR: VOLTAGE_LOW. 
  VALVE_STATE: UNKNOWN. BLINKING_SOS.

Maria_TLA_Verifier.jar: (14:01:05) FATAL: Invariant violated! 
  System is in a state where (isPouring = false) AND 
  (glassPresent = true) which was proven to be impossible. 
  Halting the universe to prevent data corruption.

Ivan_Zapier_Webhook: (14:01:06) SUCCESS: Command !POUR_BEER!
  successfully written to Google Sheets, row 257.

Legacy-Core.sh (from /var/log/syslog): (14:01:07) Water valve 
  access denied. User !BaaS_Service! not in sudoers file. 
  This incident will be reported.

\end{minted}





\subsection*{Climax: The Untouchable and His Wrath}

Somehow, the system worked. The robot could pick up a glass and bring it to the tap. But the beer wouldn't flow. Peter's valve wouldn't open. After two days of debugging with an oscilloscope and LED-based Morse code, the cause was found.

Peter's driver used a USB port on the PC to power its COM port adapter. But to ensure "maximum stability," he only used one, "lucky" USB port. It turned out that Ivan, while deploying his Docker empire, had written a \hcode{udev} rule that disabled all USB ports except for the one his mechanical keyboard with RGB lighting was plugged into, "to prevent unauthorized devices."

But the real horror was yet to come. The main water valve, controlled by the infamous \hcode{legacy-core.sh}, was not just for the building's water supply. It also fed the cooling circuit for the powerful PSU Peter had repurposed for his manipulator. When Ivan's \hcode{Orchestrator.py}, running without privileges, tried to access the valve, \hcode{legacy-core.sh} didn't just deny it. As its mysterious creator, Dmitri, had intended, it initiated a defensive measure: it shut the valve for one hour and sent an angry email to the system administrator.

The power supply began to overheat.

The smell of burning plastic filled the air. Maria started updating her ontology, adding a \textit{ThermalAnomalу} state. Ivan was googling ''how to extinguish a server with Docker''. And Peter, grabbing a fire extinguisher, ran towards the robot, shouting words not typically found in technical monographs.

Their Frankenstein was alive. And it was furious.








\section{Demo or Die}
\label{sec:parable_demoday}

Demo Day is a sacred event in the startup world. It's not just a product showcase; it's a performance, a ''narrative-crafting session.'' Steve, their investor, had invited not only the client but also bloggers from TechCrunch, several venture capitalists, and his mom.

Ivan was prepared. He had set up a ''Live Dashboard'' on a big screen using Grafana, which showed, in real-time, the number of online microservices, latency to AWS, and the price of Bitcoin. It had nothing to do with the robot, but it looked very high-tech.

Maria had prepared a 15-page presentation proving that their architecture was ''ready to scale to a trillion servings of beer per nanosecond.''

Peter just brought a fire extinguisher and placed it in the corner. ''Just in case,'' he explained.

\subsection*{Act One: The Illusion of Success}

The demo began. ''Colleagues, investors, Mom!'' Steve started. ''Today, you will see the future. Not just a robot. You will see an ecosystem. A platform. A new paradigm. We call it \textbf{Beer-as-a-Service}.''

Ivan ran the main script. The graphs on the dashboard danced. The robot smoothly came to life. It picked up a pristine glass and brought it to the tap. Everyone held their breath.

Ivan clicked the ''Pour IPA'' button in his React interface.
The \hcode{Orchestrator.py} received the command.
It flew into Kafka, was recorded on the blockchain, passed through three Redis instances, and landed in the Google Sheet.
Peter's driver read cell A27, translated ''POUR\_IPA" into its secret binary language, and sent 24 volts to the valve.
A hiss was heard, and a golden liquid streamed into the glass.

The room erupted in applause. A tear rolled down Steve's cheek. The bloggers started live-tweeting.

"But that's not all!" Ivan exclaimed. "Our system is fully customizable! The user can select the IBU level!" He moved the "IBU" slider in the interface.

\subsection*{Act Two: The Entropic Collapse}

At that moment, the unexpected happened. The Wi-Fi in the room, which Ivan's laptop was connected to, flickered for a second. That was enough.

\begin{enumerate}
    \item The React app, having lost its connection, resent the IBU change request three times.
    \item The \hcode{Orchestrator.py} received three identical requests. Since Maria had never explained "idempotency" to Ivan, it dutifully processed all three, creating three parallel "Saga transactions."
    \item Three "Change Recipe" commands flew into Kafka. A "message storm" began.
    \item Peter's driver, receiving a stream of garbage XML tags from the TCP socket generated by three parallel processes, did what it did best: it entered safe mode. It simply stopped responding, preserving the last state of the valve: open.
\end{enumerate}

Beer continued to pour. Onto the floor.

"A minor network fluctuation, the system will self-heal now," Ivan said confidently, frantically restarting Docker containers.

But the system did not self-heal. The \hcode{Maria_TLA_Verifier.jar}, detecting a discrepancy between its model ("beer is not pouring") and reality (the humidity sensor under the robot, which Peter had installed, started reporting 100\%), performed its sole function: to prevent "data desynchronization," it sent a \hcode{SIGKILL} to every process it could reach, including \hcode{legacy-core.sh}.

The \hcode{legacy-core.sh}, as it died, executed its \hcode{trap '' EXIT} command and, as Dmitri had intended, shut off the main water valve in the building as a safety precaution.

The cooling for the power supply stopped.

\subsection*{Act Three: The Finale}

"And now..." Steve tried to save the situation, "a demonstration of our premium product: \textbf{Hard BaaS}!"

The client, the owner of a chain of craft bars, requested, "Can I get a cider? A dry, apple one."

Ivan, now in a full-blown panic, found the "Pour Cider" button in the interface. He clicked it. It was a fatal mistake. Nobody knew that cider production required a different type of pump, one that needed 36 volts. Peter knew this and had hardcoded it in his driver: 

\hcode{if (recipe == "CIDER") \{ set_voltage(36); \}}.

But Ivan, in his cloud system, stored recipes as JSON. And his version of the recipe said \hcode{beverage_type}: \hcode{cider}. Lowercase.

Peter's driver found no match for \hcode{''CIDER'' == ''cider''}. Following the \hcode{else} logic, it supplied the standard 24 volts. The cider pump, not receiving enough power, seized and caused a short circuit.

At that exact moment, the overheating power supply, deprived of cooling, lit up like a Christmas tree and blew the circuit breakers for the entire building.

Total darkness fell. The only source of light was Maria's laptop screen, running on battery, which displayed a single final message:

\begin{infobox}{Final System State}
\hcode{Theorem Proved: System has successfully transitioned to a terminal, non-recoverable safe state.}
\end{infobox}

In the silence, Peter's voice was heard. "I told you so."

\section{The Beginning of Real Engineering}

The next day, the team sat in the dark office, which smelled of burnt plastic and stale beer.

"My dashboard showed 99.99\% uptime," Ivan said quietly.
"My valve didn't leak," Peter grumbled.
"My formal model predicted the failure," Maria stated.

And for the first time, they understood. They were all right. And they were all completely wrong. The problem wasn't Python or C++, Docker or relays, Agile or formal verification.

\begin{dangerbox}{Anti-Pattern: Building a Technological Frankenstein} % Заголовок отражает суть предупреждения
The problem was that they didn't have a \textbf{system}. They had built not a robot, but stitched together from pieces of different philosophies.
\begin{itemize}
    \item They had mixed \textbf{Hype-Driven Development} with "trench-warfare" reliability.
    \item They had ignored the boundary between the \textbf{fast, unpredictable world of the web (NRT)} and the \textbf{slow, deterministic world of hardware (RT)}.
    \item Their data flew around like frightened birds, with no clear \textbf{layers or interfaces}.
    \item They tried to solve every problem with the trendiest or the most robust tool, forgetting to ask the main question: \textbf{"What problem are we actually solving?"}
\end{itemize}
\end{dangerbox}

This book is the post-mortem of the "Beer-as-a-Service" project. It is an attempt to take Ivan's brilliant vision, Peter's unyielding reliability, and Maria's architectural rigor and combine them into a system that actually works. A system where different approaches don't fight, but complement each other.

We will start from the very beginning. With the fundamental principles that allow one to distinguish an engineering system from a pile of code. Welcome to the world of real control system architecture.