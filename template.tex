% ===================================================================
% --- НАЧАЛО ДОКУМЕНТА ---
% ===================================================================
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Декомпозиция и интерфейсы}
\label{sec:decomposition}

Это вводный раздел, который объясняет ключевые концепции. Мы используем \textbf{жирный шрифт} для выделения терминов и \textit{курсив} для акцентов. Правильная декомпозиция — это разделение системы на независимые, автономные единицы. В таблице~\ref{tab:honest_vs_dishonest_module} мы сравним два подхода.

\begin{itemize}
    \item \textbf{Высокая связность внутри (High Cohesion):} Всё внутри компонента служит одной цели.
    \item \textbf{Низкая связанность снаружи (Low Coupling):} Компонент как можно меньше знает о других.
\end{itemize}

\begin{box_danger}
    \textbf{Декомпозиция по структуре папок.}
    
    Если вы вынесли код в отдельный файл, например, \texttt{inverse\_kinematics.cpp}, и положили его в папку \texttt{kinematics}, вы ещё не создали модуль. Вы просто аккуратно разложили файлы.
\end{box_danger}


\subsection{Признаки правильной декомпозиции}
\label{subsec:decomposition_signs}

Рассмотрим таблицу с признаками «честного» и «нечестного» модуля. Она создана с помощью пакета \texttt{tabularray}.

\begin{longtblr}[
  caption = {Признаки «честного» и «нечестного» модуля},
  label = {tab:honest_vs_dishonest_module},
]{
  width = \linewidth,
  colspec = {|X[0.8,l,t] | X[1.2,l,t] | X[1.2,l,t]|},
  rowhead = 1,
  hlines,
  hline{1,Z} = {1pt, solid},
  hline{2} = {0.5pt, solid},
  row{1} = {font = \bfseries},
  row{1-Z} = {font = \setstretch{0.9}},
  column{1} = {font = \bfseries},
}
% --- Заголовок таблицы ---
Характеристика & 
Признак «нечестного» модуля & 
Признак «честного» модуля \\

% --- Содержимое таблицы ---
Цель &
Размыта. Модуль делает несколько несвязанных вещей. &
Единственная, чётко определённая цель. \\

Автономность &
Не может работать без десятка других «вспомогательных» модулей. &
Способен работать в изоляции. \\

Тестируемость &
Невозможно протестировать без запуска всей системы. &
Легко тестируется в изоляции (модульное тестирование). \\
\end{longtblr}

\begin{box_important}
    Пример хорошей декомпозиции: система разделена на иерархические слои, где каждый слой общается только со своими соседями сверху и снизу через чётко определённые интерфейсы.
\end{box_important}


\subsection{Визуализация и контракты}
\label{subsec:visualization_contracts}

На рисунке~\ref{fig:architectural_layers} показана концептуальная диаграмма слоёв. Это всего лишь заглушка, но она демонстрирует, как вставлять плавающие объекты.

\begin{figure}[h!]
    \centering
    \begin{tcolorbox}[width=\textwidth, colback=white, colframe=black, sharp corners, halign=center, valign=center]
        \textbf{Placeholder for Diagram}
        \vspace{1cm}
        
        \textit{Здесь могла бы быть ваша диаграмма слоёв.}
        
        \texttt{Слой A $\rightarrow$ Слой B $\rightarrow$ Слой C}
        
    \end{tcolorbox}
    \caption{Пример слоистой архитектуры.}
    \label{fig:architectural_layers}
\end{figure}

Инженерный интерфейс — это не просто API, а контракт.

\begin{box_tip}
    \textbf{Пример концептуального контракта}

    \begin{description}
        \item[Назначение:] Описание того, что делает компонент.
        \item[Входные данные:] Что компонент принимает на вход.
        \item[Выходные данные:] Что компонент возвращает.
        \item[Гарантии:] Что компонент обязуется выполнить (например, время ответа < 300 мкс).
        \item[Обработка сбоев:] Как компонент ведёт себя при ошибке.
    \end{description}
\end{box_tip}

\lipsum[2] % Вставка случайного текста для заполнения страницы

\end{document}
% ===================================================================
% --- КОНЕЦ ДОКУМЕНТА ---
% =========================